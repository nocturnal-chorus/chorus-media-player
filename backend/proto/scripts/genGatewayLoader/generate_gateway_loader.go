package main

import (
	"bytes"
	"fmt"
	"html/template"
	"log"
	"os"
	"path"
	"path/filepath"
	"strings"
)

const (
	ProtoPath       = "../../"
	GatewayFileName = "service.pb.gw.go"
	LoaderName      = "gatewayLoader.go"
)

var (
	loaderTemplate = template.Must(template.New("loader").Parse(
		`
// Code generated by generate-gateway-loader. DO NOT EDIT

package proto

import (
	"context"
	"fmt"
	"strings"

	{{range .Services}} "github.com/nocturnal-chorus/chorus-media-player/proto/{{.ServiceName}}"
	{{end}}

	"github.com/grpc-ecosystem/grpc-gateway/v2/runtime"
	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials/insecure"
	"net/http"
)

func NewGateway(ctx context.Context) (http.Handler, error) {
	var (
		err error
		mux = runtime.NewServeMux()
	)

	{{range .Services}}
	{{.ServiceName}}Opts := []grpc.DialOption{grpc.WithTransportCredentials(insecure.NewCredentials())}
	err = {{.ServiceName}}.Register{{.UpperName}}ServiceHandlerFromEndpoint(ctx, mux, genEndpointByService("{{.ServiceName}}Service"), {{.ServiceName}}Opts)
	if err != nil {
		return nil, err
	}
	{{end}}
	
	return mux, err
}

func genEndpointByService(serviceName string) string {
	return fmt.Sprintf("player-%s-service:8091", strings.ToLower(strings.Replace(serviceName, "Service", "", -1)))
}

`,
	))
)

type services struct {
	Services []service
}

type service struct {
	ServiceName string
	UpperName   string
}

func main() {
	var (
		s   = services{}
		err error
	)

	cmdPath, _ := filepath.Abs(filepath.Dir(os.Args[0]))
	fmt.Println(cmdPath)
	s.Services, err = getServices(path.Join(cmdPath, ProtoPath))
	if err != nil {
		return
	}
	if err != nil {
		panic(err)
	}

	fmt.Println(s.Services)

	w := bytes.NewBuffer(nil)
	err = loaderTemplate.Execute(w, s)
	if err != nil {
		panic(err)
	}
	fmt.Println(string(w.Bytes()))
	loaderPath := path.Join(cmdPath, ProtoPath, LoaderName)
	loader, err := os.Create(loaderPath)
	if err != nil {
		log.Println(err)
		return
	}
	loader.Write(w.Bytes())
	loader.Close()
}

func getServices(protoPath string) ([]service, error) {
	dirs, err := os.ReadDir(protoPath)
	if err != nil {
		return nil, err
	}

	var result []service
	for _, dir := range dirs {
		stubPath := path.Join(protoPath, dir.Name(), GatewayFileName)
		_, err := os.Stat(stubPath)
		if os.IsNotExist(err) || err != nil {
			continue
		}
		result = append(result, service{
			ServiceName: dir.Name(),
			UpperName:   fmt.Sprintf("%s%s", string(strings.ToUpper(dir.Name())[0]), dir.Name()[1:]),
		})
	}
	return result, nil
}
